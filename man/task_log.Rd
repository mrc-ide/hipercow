% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/task.R
\name{task_log_show}
\alias{task_log_show}
\alias{task_log_value}
\alias{task_log_watch}
\title{Get task log}
\usage{
task_log_show(id, outer = FALSE, follow = TRUE, root = NULL)

task_log_value(id, outer = FALSE, follow = TRUE, root = NULL)

task_log_watch(
  id,
  poll = 1,
  skip = 0,
  timeout = NULL,
  progress = NULL,
  follow = TRUE,
  root = NULL
)
}
\arguments{
\item{id}{The task identifier}

\item{outer}{Logical, indicating if we should request the "outer"
logs; these are logs from the underlying HPC software before it
hands off to hipercow.}

\item{follow}{Logical, indicating if we should follow any retried
tasks.}

\item{root}{A hipercow root, or path to it. If \code{NULL} we search up
your directory tree.}

\item{poll}{Time, in seconds, used to throttle calls to the status
function. The default is 1 second}

\item{skip}{Optional integer indicating how to handle log content
that exists at the point where we start watching. The default
(0) shows all log contents.  A positive integer skips that many
lines, while a negative integer shows only that many lines (so
-5 shows the first five lines in the log).  You can pass \code{Inf}
to discard all previous logs, but stream all new ones.}

\item{timeout}{The time to wait for the task to complete. The
default is to wait forever.}

\item{progress}{Logical value, indicating if a progress spinner
should be used. The default \code{NULL} uses the option
\code{hipercow.progress}, and if unset displays a progress bar in an
interactive session.}
}
\value{
Depending on the function:
\itemize{
\item \code{task_log_show} returns the log value contents invisibly, but
primarily displays the log contents on the console as a side
effect
\item \code{task_log_value} returns a character of log contents
\item \code{task_log_watch} returns the status converted to logical (as
for \link{task_wait})
}
}
\description{
Get the task log, if the task has produced one.  Tasks run by the
\code{dide-windows} driver will generally produce a log.  A log might be
quite long, and you might want to print it to screen in its
entirety (\code{task_log_show}), or return it as character vector
(\code{task_log_value}).
}
\details{
The function \code{task_log_watch} has similar semantics to
\link{task_wait} but does not error on timeout, and always displays a
log.
}
\examples{
cleanup <- hipercow_example_helper(with_logging = TRUE)

# Tasks that don't produce any output (print, cat, warning, etc)
# will only contain logging information from hipercow itself
id <- task_create_expr(runif(1))
task_wait(id)
task_log_show(id)

# If your task creates output then it will appear within the
# horizontal rules:
id <- task_create_explicit(quote({
  message("Starting analysis")
  x <- mean(runif(100))
  message("all done!")
  x
}))
task_wait(id)
task_log_show(id)

# Use "task_log_value" to get the log value as a character vector
task_log_value(id)

# Depending on the driver you are using, there may be useful
# information in the "outer" log; the logs produced by the
# submission system before hipercow takes over:
task_log_show(id, outer = TRUE)

cleanup()
}
